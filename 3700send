#!/usr/bin/python -u
#
# CS3700, Spring 2017
#

import sys
import socket
import time
import datetime
import select
import json
import Queue
MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
RTO = 200

# Retransmission queue
retransmission_queue= {}

last_ack_received = 0
last_frame_sent = 0

# Initial window size
INITIAL_WINDOW_SIZE = 5

current_window_size = INITIAL_WINDOW_SIZE

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Keys
SEQUENCE_KEY = "sequence"
DATA_KEY = "data"
EOF_KEY = "eof"
ACK_KEY = "ack"


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# Returns current time in milliseconds
def current_time():
    return int(round(time.time() * 1000))

# Read a JSON object from the socket and return it as a Python object
def getJSON():
    global MSG_SIZE
    result = sock.recvfrom(MSG_SIZE)
    if result:
        return json.loads(result[0])

def send_next_packet():
    global current_window_size
    global SEQUENCE_KEY
    global DATA_KEY
    global EOF_KEY
    global last_frame_sent

    # Read DATA_SIZE bytes
    data = sys.stdin.read(DATA_SIZE)
    if len(data) > 0:
        msg = json.dumps({SEQUENCE_KEY: last_frame_sent, DATA_KEY: data, EOF_KEY: False})
        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")

        log("[send data] Sequence:" + str(last_frame_sent) + " Size:" + str(len(data)) + "")

        last_frame_sent += len(data)
        current_window_size -= 1
        retransmission_queue[last_frame_sent] = (msg, current_time())

        return True
    else:
        # Only end transmission if there are no packets to be retransmitted
        if len(retransmission_queue) is 0:
            endTransmission()

# Retransmit the packet
def retransmit(sequence):
    global retransmission_queue
    global current_window_size

    # Get the packet to be resent
    remsg = retransmission_queue[sequence][0]

    log("[resent data] " + str(sequence) + " (" + str(len(json.loads(SENTPACKETS[sequence])[DATA_KEY])) + ")")
    if sock.sendto(remsg, dest) < len(remsg):
        log ("[error] unable to fully resend packet")
    else:
        # Restart retransmission timer
        retransmission_queue[sequence][1] = current_time()


def endTransmission():
    global DATA_KEY
    global SEQUENCE_KEY
    global EOF_KEY

    sock.sendto(json.dumps({EOF_KEY: True, DATA_KEY: "", SEQUENCE_KEY: last_frame_sent}), dest)
    log("[send eof] Sequence: " + str(last_frame_sent))

    # Wait for eof ACK
    while True:
        decoded = getJSON()
        if decoded[EOF_KEY]:
            # Received eof from receiver, so exit
            sys.exit()
        else:
            break

    # Failed to get ACK for the eof, so try again
    endTransmission()


# Iterate over the retransmission queue, checking for
# packets that need retransmission
def retransmission_check():
    global retransmission_queue
    global RTO

    for (key, value) in enumerate(retransmission_queue.iteritems()):
        if value[1] < current_time() - RTO:
            retransmit(key)

def handle_ack(decoded):
    global ACK_KEY
    global DATA_KEY

    ack = decoded[ACK_KEY]
    last_ack_received = ack

    log(str(decoded))
    if ack > last_ack_received and ack <= last_frame_sent:
        log("okay")



# Main
def start():
    global current_window_size

    # Begin by sending as many packets as the window allows
    while current_window_size > 0:
        if not send_next_packet():
            break

    # Now read in data, send packets
    while True:
        print "Window is " + str(current_window_size)
        decoded = getJSON()
        if decoded:
            handle_ack(decoded)

        # Iterate over the retransmission queue, checking for
        # packets that need retransmission
        retransmission_check()




start()
