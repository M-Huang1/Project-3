#!/usr/bin/python -u
#
# CS3700, Spring 2017
#

import sys
import socket
import time
import datetime
import select
import json
import Queue
MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
RTO = 200

# Retransmission queue
retransmission_queue= {}

last_ack_received = 0
last_frame_sent = 0

# Initial window size
INITIAL_WINDOW_SIZE = 5

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Keys
SEQUENCE_KEY = "sequence"
DATA_KEY = "data"
EOF_KEY = "eof"
ACK_KEY = "ack"


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# Returns current time in milliseconds
def current_time():
    return int(round(time.time() * 1000))

# Read a JSON object from the socket and return it as a Python object
def getJSON():
    global MSG_SIZE
    result = sock.recvfrom(MSG_SIZE)
    if result:
        return json.loads(result[0])

def send_next_packet():
    global SEQUENCE_KEY
    global DATA_KEY
    global EOF_KEY
    global last_frame_sent

    # Read DATA_SIZE bytes
    data = sys.stdin.read(DATA_SIZE)
    if len(data) > 0:
        msg = json.dumps({SEQUENCE_KEY: last_frame_sent, DATA_KEY: data, EOF_KEY: False})
        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")

        log("[send data] Sequence:" + str(last_frame_sent) + " Size:" + str(len(data)) + "")

        last_frame_sent += len(data)
        retransmission_queue[last_frame_sent] = (msg, current_time())

        return True
    else:
        # Only end transmission if there are no packets to be retransmitted
        if len(retransmission_queue) is 0:
            endTransmission()

# Retransmit the packet
def retransmit(sequence):
    global retransmission_queue

    # Get the packet to be resent
    remsg = retransmission_queue[sequence][0]

    log("[resent data] " + str(sequence) + " (" + str(len(json.loads(SENTPACKETS[sequence])[DATA_KEY])) + ")")
    if sock.sendto(remsg, dest) < len(remsg):
        log ("[error] unable to fully resend packet")
    else:
        # Restart retransmission timer
        retransmission_queue[sequence][1] = current_time()


def endTransmission():
    global DATA_KEY
    global SEQUENCE_KEY
    global EOF_KEY

    sock.sendto(json.dumps({EOF_KEY: True}), dest)
    log("[send eof]")

    # Wait for eof ACK
    while True:
        decoded = getJSON()
        if decoded[EOF_KEY]:
            # Received eof from receiver, so ack and then exit
            sock.sendto(json.dumps({EOF_KEY: True}), dest)
            sock.sendto(json.dumps({EOF_KEY: True}), dest)
            sock.sendto(json.dumps({EOF_KEY: True}), dest)
            log("[completed]")
            sys.exit()
        else:
            break

    # Failed to get ACK for the eof, so try again
    endTransmission()


# Iterate over the retransmission queue, checking for
# packets that need retransmission
def retransmission_check():
    global retransmission_queue
    global RTO

    for (key, value) in enumerate(retransmission_queue.iteritems()):
        if value[1] < current_time() - RTO:
            retransmit(key)

def handle_ack(decoded):
    global ACK_KEY
    global DATA_KEY
    global last_frame_sent
    global last_ack_received

    ack = decoded[ACK_KEY]

    log(str(decoded))
    if ack > last_ack_received and ack <= last_frame_sent:
        last_ack_received = ack
        del retransmission_queue[last_ack_received]

def current_window_size():
    return INITIAL_WINDOW_SIZE - ((last_frame_sent - last_ack_received) / DATA_SIZE)



# Main
def start():

    # Begin by sending as many packets as the window allows
    while current_window_size() > 0:
        if not send_next_packet():
            break

    # Now read in data, send packets
    while True:
        print "Window is " + str(current_window_size())
        decoded = getJSON()
        if decoded:
            handle_ack(decoded)

        # Iterate over the retransmission queue, checking for
        # packets that need retransmission
        retransmission_check()

        if current_window_size() > 0:
            send_next_packet()




start()
